What is the Goal of the Return to libc Attack?
1.  We need to run a shell.
2.  That means we need a return address in the RT field on the stack that
    takes us the the system function.

Return to libc Challenges
1.  What is the address of the system function defined in libc?
2.  We have to put the string "/bin/sh" in memory then we have to get
    the address of that string to pass to the system function.
3.  The most difficult challenge is how to pass the address of the
    command string to the system function.

How do we get the address of the system function in libc?
1.  gdb -q stack (Section 4 .../lib/bin)
2.  b main
3.  run
4.  p system
    $1 = {<text variable, no debug info>} 0xb7e42da0 <__libc_system>
5.  You must run gdb against the vulnerable program, not some other.
6.  It has to be EXACTLY the same program you are going to use in the
    attack.

How do we get the address of "/bin/sh"?
1.  We have to push this string into memory ourselves.
2.  We define an environment variable in the parent shell process and
    that will be passed to the child so that is how we get the string
    into memory.

How do we get the address of "/bin/sh" into the system function?
1.  Getting the address of the system function into RT on stack of our
    buffer overflow progam is easy. The problem is that when the system
    function loaded into a stack frame, the ebp points to some unknown
    location.
2.  We have to have the address of the ebp so that can use ebp + 8 to
    the "/bin/bash" argument in the proper location of the system call
    stack frame pointer.
3.  The ebp pointer changes in two ways: when a function is entered and
    when that function exits. See prog.s that was generated by:
    gcc -S prog.c.
4.  The value of ebp depends on the value of esp (execution stack pointer).
5.  So, based on video 43, the ebp value is going to become esp + 4 at
    in the function Prologue. This is the result of operations going on
    in the function Epilogue.

Return to libc Attack
1.  sysctl -w kernel.randomize_va_space=0
    kernel.randomize_va_space = 0
2.  cd /bin; ln -sf zsh sh 
3.  gcc -z noexecstack -fno-stack-protecter -o bin/stack stack.c
4.  sudo chown root stack; sudo chmod 4755 stack; ls -al
5.  export MYSHELL="/bin/sh"
6.  gdb -q stack
    1.  b main
    2.  p system
    3.  p MYSHELL
    4.  p exit
7.  Put these addresses in either exploit.c or exploit.py and the attack
    will work!
